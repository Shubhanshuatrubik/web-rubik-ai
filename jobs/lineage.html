<!DOCTYPE html>
<meta charset="utf-8">
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.2/d3.min.js"></script> -->
<script src="https://d3js.org/d3.v5.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


<style>
  #controls {
    position: fixed;
    left: 0px;
    width: 100%;
    top: 0px;
    height: 10%;
  }

  #chart {
    position: fixed;
    left: 0px;
    right: 0px;
    top: 0px;
    bottom: 0px;
  }

  path.link {
    fill: none;
    stroke: #c5c5c5;
    stroke-width: 1.0px;
  }

  circle,
  rect {
    fill: #e6e4e4!important;
    stroke: #fff;
    stroke-width: 1.5px;
  }
  .main-dataset {
    fill:#4796d8!important;
  }


  text {
    fill: #000000;
    font-size: 12px;
    font-weight: lighter;
    font-family: Arial, Helvetica, sans-serif;
  }

  .ingoing {
    stroke: #237690 !important;
    letter-spacing: 2px;
    font-weight: 100!important;
    font-size: 12px;
    -webkit-text-stroke: unset;
  }
  .ingoing-text {
    color: #237690 !important;
    -webkit-text-stroke-width:0px!important;
    letter-spacing: 2px;
    font-weight: 100!important;
    font-size: 12px;
  }

  .outgoing {
    stroke: #FA1209 !important;
     letter-spacing: 2px;
     font-size: 12px;
     font-weight: lighter;
  }
  .outgoing-text {
    color: #FA1209 !important;
    -webkit-text-stroke-width:0px!important;
    letter-spacing: 2px;
    font-weight: 100!important;
    font-size: 12px;
  }

  .selected {
    stroke: #000000 !important;
    letter-spacing: 2px;
    font-weight: lighter;
    font-size: 12px;
  }
  .selected-text {
    color: #000000;
    letter-spacing: 2px;
    -webkit-text-stroke-width:0px!important;
  }


  .float-right {
    float: right;
    margin-right: 10px;
  }

  .test {
    margin-top: 50px;
    margin-left: 150px;
  }

  .tooltip {
    position: absolute;
    text-align: center;
    line-height: 22px;
    padding: 2px 8px;
    width: 100px;
    height: 50px;
    font: 12px;
    stroke: #000000;
    fill: #ccc;
    border-radius: 5px;
    box-shadow: 0 3px 5px -1px rgba(0, 0, 0, .2), 0 6px 10px 0 rgba(0, 0, 0, .14), 0 1px 18px 0 rgba(0, 0, 0, .12);
    border: 1px solid #a09c9c;
    pointer-events: none;
    white-space: nowrap;
  }
  #cb_hierarchical, #cb_curved {
    display: none;
  }

</style>

<body>
  <div id="chart"></div>



  <div id="controls">
    <input type="checkbox" id="cb_hierarchical" checked="True" onclick='redraw();'>
    <input type="checkbox" id="cb_curved" checked="True" onclick='redraw();'>
    <button class="float-right" id="zoom_out"> -</button>
    <button class="float-right" id="zoom_in">+</button>
  </div>



  <script>
    graph = {
      "directed": true, "graph": [], "nodes": [{ "id": 0, "name": "dataset_0", "level": 0, "type": "dataset" }, { "id": 1, "name": "dataset_1", "level": 0, "type": "dataset" }, { "id": 2, "name": "dataset_2", "level": 0, "type": "dataset" }, { "id": 3, "name": "dataset_3", "level": 0, "type": "dataset" }, { "id": 4, "name": "job_4", "level": 1, "type": "job" }, { "id": 5, "name": "job_5", "level": 1, "type": "job" }, { "id": 6, "name": "dataset_6", "level": 2, "type": "dataset" }, { "id": 7, "name": "dataset_7", "level": 2, "type": "dataset" }, { "id": 8, "name": "dataset_8", "level": 2, "type": "dataset" }, { "id": 9, "name": "dataset_9", "level": 2, "type": "dataset" }, { "id": 10, "name": "job_10", "level": 3, "type": "job" }, { "id": 11, "name": "dataset_11", "level": 4, "type": "dataset" }, { "id": 12, "name": "dataset_12", "level": 4, "type": "dataset" }, { "id": 13, "name": "dataset_13", "level": 4, "type": "dataset" }, { "id": 14, "name": "job_14", "level": 5, "type": "job" }, { "id": 15, "name": "job_15", "level": 5, "type": "job" }, { "id": 16, "name": "dataset_16", "level": 6, "type": "dataset" }], "links": [{ "source": 0, "target": 4 }, { "source": 1, "target": 4 }, { "source": 2, "target": 5 }, { "source": 3, "target": 5 }, { "source": 4, "target": 6 }, { "source": 5, "target": 7 }, { "source": 6, "target": 10 }, { "source": 6, "target": 14 }, { "source": 8, "target": 10 }, { "source": 7, "target": 10 }, { "source": 9, "target": 15 }, { "source": 10, "target": 11 }, { "source": 11, "target": 15 }, { "source": 12, "target": 14 }, { "source": 13, "target": 14 }, { "source": 14, "target": 16 }, { "source": 15, "target": 16 }, { "source": 0, "target": 10 }], "multigraph": false
    }

    var cb_hierarchical = document.getElementById("cb_hierarchical");
    var cb_curved = document.getElementById("cb_curved");
    var chartDiv = document.getElementById("chart");
    var svg = d3.select(chartDiv).append("svg");

    var linkedByIndex = {};
    var num_links = {};
    var num_links_incoming = {};
    const maxlevel = graph.nodes.reduce(function (currentValue, node) {
      return Math.max(node.level, currentValue);
    }, 0);
    var margin_range = [0, 5, 10, 15];
    var randList = [];

    graph.links.forEach(function (d) {
      linkedByIndex[d.source + "," + d.target] = 1;
      num_links[d.target] = (num_links[d.target] != undefined ? num_links[d.target] + 1 : 1)
      num_links[d.source] = (num_links[d.source] != undefined ? num_links[d.source] + 1 : 1)
      num_links_incoming[d.target] = (num_links_incoming[d.target] != undefined ? num_links_incoming[d.target] + 1 : 1)
      d.distance = graph.nodes[d.target].level - graph.nodes[d.source].level;
      if (graph.nodes[d.target].level == maxlevel){
        randList.push(10);
      }else {
        var x = margin_range.shift();
        randList.push(x);
        margin_range.push(x);
      }
    });

    // const maxlevel = graph.nodes.reduce(function (currentValue, node) {
    //   return Math.max(node.level, currentValue);
    // }, 0);
    var maxlinks = Object.values(num_links).reduce(function (currentValue, entry) {
      return Math.max(entry, currentValue);
    }, 0);




    var parentContainer = svg.append('g').attr('id', 'main-container')

    var white_background = parentContainer.append("svg:defs")
      .append("filter")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 1)
      .attr("height", 1)
      .attr("id", "white_background");

    white_background
      .append("feFlood")
      .attr("flood-color", "white");

    white_background
      .append("feComposite")
      .attr("in", "SourceGraphic")


    var simulation = d3.forceSimulation(graph.nodes)
      .on('tick', tick);

    // add the links
    var path = parentContainer.selectAll("path")
      .data(graph.links)
      .enter().append("svg:path")
      .attr("class", "link");

    // define the nodes
    var node = parentContainer.selectAll(".node")
      .data(graph.nodes)
      .enter().append("g")
      .attr("class", function (d) {
        if (d.type == 'job') {
          return 'node rect';
        } else if (d.type == 'dataset') {
          return 'node circle';
        }
      })
      .on("mouseover",highlight(true))
      .on("mouseout", highlight(false))
      .on("mouseenter", function (d, i) {
        if (d.level !== maxlevel) {
          tooltip
            .transition()
            .attr('d', topTooltipPath(150, 70, 15, d.x, d.y))
            .style("opacity", 0.9)
        }
      })
      .on("mouseleave", function (d) {
        tooltip.style("opacity", 0);
      })
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    // adding the node-circles
    var circle = parentContainer.selectAll(".circle").append("circle")
      .attr("z", 0)
      .attr('class', function (d) {
        if (d.type == "dataset") {
          return "dataset"
        } else if (d.type == "job") {
          return "job"
        }
      });

    //adding rect nodes
    var rect = parentContainer.selectAll('.rect').append('rect')
      .attr('z', 0)
      .attr('width', 60)
      .attr('height', 30)
      .attr('rx', 10)
      .attr('ry', 20)
      .attr('class', function (d) {
        if (d.type == "dataset") {
          return "dataset"
        } else if (d.type == "job") {
          return "job"
        }
      });


    // add the text to nodes
    var title = node.append("text")
      .attr("x",
        function (d) {
          if (d.type == 'dataset') {
            return 10;
          } else if (d.type == 'job') {
            return 50;
          }
        })
      .attr("z", 20)
      .attr("dy", function (d) {
        if (d.type == 'dataset') {
          return 5;
        } else if (d.type == 'job') {
          return 20;
        }
      })
      /* .attr("filter", "url(#white_background)") */
      .text(function (d) {
        return d.name;
      });

    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart()
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function tick(e) {
      var width = chartDiv.clientWidth,
        height = chartDiv.clientHeight,
        radius = 10
      //randList = [10, 19, 8, 28, 7, 19, 9, 13, 9, 16, 10, 20, 7, 12, 19, 20, 9, 14];

      node
        .attr("cx", function (d) {
          return d.x = Math.max(d.radius, Math.min(width - d.radius - 75, d.x));
        })
        .attr("cy", function (d) {
          return d.y = Math.max(d.radius, Math.min(height - d.radius, d.y));
        })
        .attr("transform", function (d) {
          if (d.type === 'job') {
            return "translate(" + (d.x - 20) + "," + (d.y - 15) + ")";
          } else {
            return "translate(" + d.x + "," + d.y + ")";
          }
        });


      path.attr("d", function (d) {
        if (cb_curved.checked) {
          if (d.target.y > d.source.y && d.target.x > d.source.x) {
            return "M" + (d.source.x - 20) + "," + (d.source.y)
              + "h" + ((d.target.x - d.source.x) - 2 * radius - randList[d.index])
              + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + radius
              + "v" + ((d.target.y - d.source.y) - 2 * radius)
              + "a" + radius + "," + radius + " 1 0 0 " + radius + "," + radius
              + "h" + randList[d.index]

          } if (d.source.x > d.target.x && d.source.y > d.target.y) {
            return "M" + (d.source.x - 20) + "," + (d.source.y)
              + "h" + ((d.source.x - d.target.x) - 2 * radius - randList[d.index])
              + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + radius
              + "v" + ((d.source.y - d.target.y) - 2 * radius)
              + "a" + radius + "," + radius + " 1 0 0 " + radius + "," + radius
              + "h" + randList[d.index]

          } if (d.target.x > d.source.x && d.source.y > d.target.y) {
            return "M" + (d.source.x - 20) + "," + (d.source.y)
              + "h" + ((d.target.x - d.source.x) - 2 * radius - randList[d.index])
              + "a" + -radius + "," + -radius + " 1 0 0 " + radius + "," + -radius
              + "v" + (-(d.source.y - d.target.y) + 2 * radius)
              + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + -radius
              + "h" + randList[d.index]

          } if (d.target.y > d.source.y && d.source.x > d.target.x) {
            return "M" + (d.source.x - 20) + "," + (d.source.y)
              + "h" + ((d.source.x - d.target.x) - 2 * radius)
              + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + radius
              + "v" + ((d.target.y - d.source.y) - 2 * 20)
              + "a" + radius + "," + radius + " 1 0 0 " + radius + "," + radius
          }
        } else {
          return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
        }
      });
    }

    d3.selectAll('.dataset').attr('class', function (d) {
        if (d.level == maxlevel) {
          return 'dataset main-dataset';
        }
      })


    function highlight(active) {
      return function (d, i) {
        path.classed("ingoing", function (link) {
          return active && link.target === d;
        });
        path.classed("outgoing", function (link) {
          return active && link.source === d;
        });
        node.classed("ingoing", function (node) {
          return active && linkedByIndex[node.id + "," + d.id];
        });
        node.classed("outgoing", function (node) {
          return active && linkedByIndex[d.id + "," + node.id];
        });
        node.classed("selected", function (node) {
          return active && d.id === node.id;
        });
        circle.classed("ingoing", function (node) {
          return active && linkedByIndex[node.id + "," + d.id];
        });
        circle.classed("outgoing", function (node) {
          return active && linkedByIndex[d.id + "," + node.id];
        });
        circle.classed("selected", function (node) {
          return active && d.id === node.id;
        });

        rect.classed("ingoing", function (node) {
          return active && linkedByIndex[node.id + "," + d.id];
        });
        rect.classed("outgoing", function (node) {
          return active && linkedByIndex[d.id + "," + node.id];
        });
        rect.classed("selected", function (node) {
          return active && d.id === node.id;
        });

        title.classed("ingoing", function (node) {
          return active && linkedByIndex[node.id + "," + d.id];
        });
        title.classed("outgoing", function (node) {
          return active && linkedByIndex[d.id + "," + node.id];
        });
        title.classed("selected", function (node) {
          return active && d.id === node.id;
        });
      };
    }



    function redraw() {
      var width = chartDiv.clientWidth;
      var height = chartDiv.clientHeight;

      svg.attr("width", width).attr("height", height);

      const radius = 25;
      const charge = 10;
      const link_strength = .75;
      graph.nodes.forEach(function (d) {
        d.radius = radius * Math.atan((num_links[d.id] != undefined ? num_links[d.id] : 0) / maxlinks * 2 * Math.PI);
      });
      graph.nodes.forEach(function (d) {
        d.radius_inc = radius * Math.atan((num_links_incoming[d.id] != undefined ? num_links_incoming[d.id] : 0) / maxlinks * 2 * Math.PI);
      });

      circle.attr('r', function (d) {
        if (maxlevel === d.level) {
          return 30;
        } else {
          return 20;
        }
        /* return d.radius; */

      });

      var leveldist = width / (maxlevel + 1);

      if (cb_hierarchical.checked) {
        simulation
          .force('x', d3.forceX()
            .x(function (d) {
              return (d.level + 0.5) * leveldist;
            })
            .strength(2.))
          .force('y', d3.forceY()
            .y(height / 2)
            .strength(0.025));
      } else {
        simulation
          .force('x', d3.forceX()
            .x(width / 2)
            .strength(0.05))
          .force('y', d3.forceY()
            .y(height / 2)
            .strength(0.05));
      }

      simulation.force('link', d3.forceLink()
        .links(graph.links)
        .strength(function (d) {
          return link_strength / d.target.radius_inc;
        })
        .distance(function (d) {
          return d.distance * leveldist
        }))
        .force('charge', d3.forceManyBody()
          .strength(function (d) {
            return -charge * d.radius;
          }))
        .force('collision', d3.forceCollide()
          .radius(function (d) {
            return d.radius;
          }))
        .alphaTarget(0.3)
        .restart();
    }

    redraw();
    d3.select(window).on("resize", redraw)
    function zoom_actions() {
      console.log('parentContainer', parentContainer);
      parentContainer.attr("transform", d3.event.transform)
    }

    var zoom_handler = d3.zoom()
      .on("zoom", zoom_actions);

    svg.call(zoom_handler).on('wheel.zoom', null)

    // function for zoom-in & zoom-out functionality.

    var selection = d3.select('#main-container');
    var width = chartDiv.clientWidth,
      height = chartDiv.clientWidth;

    function zoomed() {
      var t = d3.zoomTransform(selection.node()); // ADDED
      parentContainer.attr("transform",
        "translate(" + t.x + "," + t.y + ")" +
        "scale(" + t.k + ")"
      );
    }

    var zoom = d3.zoom().scaleExtent([1 / 4, 8]).on("zoom", zoomed);



    function interpolateZoom(translate, scale) {
      return selection.transition().duration(50)
        .call(zoom.transform,
          d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale))
    }


    function zoomClick() {
      console.log('TARGET:', d3.event.target)
      var clicked = d3.event.target,
        direction = 1,
        factor = 0.1,
        target_zoom = 1,
        center = [width / 2, height / 2],
        extent = zoom.scaleExtent(),
        translate = d3.zoomTransform(selection.node()), // ADDED
        translate0 = [],
        l = [],
        view = { x: translate.x, y: translate.y, k: translate.k };

      d3.event.preventDefault();
      direction = (this.id === 'zoom_in') ? 1 : -1;
      console.log('DIRECTiON:', direction);
      target_zoom = view.k * (1 + factor * direction);

      if (target_zoom < extent[0] || target_zoom > extent[1]) { return false; }

      translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
      view.k = target_zoom;
      l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];

      view.x += center[0] - l[0];
      view.y += center[1] - l[1];
      console.log('center:', center);

      interpolateZoom([view.x, view.y], view.k);
    }

    d3.selectAll('button').on('click', zoomClick);

    var tooltip = svg
        .append("path")
        .attr("class", "tooltip")
        .style('z-index', 10000)
        .style("opacity", 1)
        .style('fill', '#fff')
        .style('stroke', '#CCC')


      function topTooltipPath(width, height, offset, x, y) {
        const left = x - (width / 2)
        const right = x + (width / 2)
        const top = y - (offset + height) - 20
        const bottom = y - offset - 20
        return `M ${x},${y - 20}
    L ${x - offset},${bottom}
    H ${left}
    V ${top}
    H ${right}
    V ${bottom}
    H ${x + offset}
    L ${x},${y - 20} z`
      }








  </script>
</body>

</html>
